<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Laravel | To Boldly Code...]]></title>
  <link href="http://boldlycoding.com/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="http://boldlycoding.com/"/>
  <updated>2015-03-18T03:31:54-04:00</updated>
  <id>http://boldlycoding.com/</id>
  <author>
    <name><![CDATA[George McDaid]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laravel and Advanced Routing to Controllers]]></title>
    <link href="http://boldlycoding.com/blog/2015/03/13/laravel-and-advanced-routing-to-controllers/"/>
    <updated>2015-03-13T03:08:01-04:00</updated>
    <id>http://boldlycoding.com/blog/2015/03/13/laravel-and-advanced-routing-to-controllers</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Following the previous discussion of routes and controllers, there are other constructs within the Laravel framework that are also worth noting.</p>

<h2>Parameter Constraints</h2>

<p>Laravel allows for constraints to be placed on route parameters, which were discussed in the previous post. Parameter constraints are more basic to type than route filters, but just as powerful. Route parameter constraints are implemented using regular expressions listed with an accompanying parameter name. Before a request is passed to the controller within a route function, the parameter must satisfy the regular expression.</p>

<p>The first route must only be alphabetical, while the second must be numerical. Laravel will only dispatch a request to these routes if the parameter meets the regular expression.
&#8220;`
Route::get(&lsquo;user/{name}&rsquo;, function($name)
{
    //
})
->where(&lsquo;name&rsquo;, &lsquo;[A-Za-z]+&rsquo;);</p>

<p>Route::get(&lsquo;user/{id}&rsquo;, function($id)
{
    //
})
->where(&lsquo;id&rsquo;, &lsquo;[0-9]+&rsquo;);
&#8220;`</p>

<p>The routes can also be combined and pass an array of constraints
<code>
Route::get('user/{id}/{name}', function($id, $name)
{
    //
})
-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+'])
</code></p>

<p>Although not this it is not found within the routing file, it is useful to note the <em>firstOrFail</em> and <em>findOrFail</em> functions here. These functions are used to find data within a table using an identifier, when the record is not found, an exception is thrown. This failure can then propagate up to a 404 error page, and no routing or redirection is needed within the controller. <em>findOrFail($id)</em> is used when the identifier being used is the primary key, <em>firstOrFail()</em> is used when the identifier is not the primary key.</p>

<p>This function will fail if the content identifier does not exist. The error can be caught in the app&rsquo;s config file and a 404 view can be presented.
&#8220;`
public function getContent($content = null){
    $view = View::make(&lsquo;content&rsquo;);</p>

<pre><code>$content = Content::findOrFail($id);

$view-&gt;with('content', $content);

return $view;
</code></pre>

<p>}
&#8220;`</p>

<p>Another variation with the <em>firstOrFail</em> function, here the primary key is not used. The content URL is compared to other URLs in the database.
&#8220;`
public function getContent($url = null)
{</p>

<pre><code>    $view = View::make('content');

    $content = Content::where('url', '=', $url)-&gt;firstOrFail();

    $view-&gt;with('content', $content);

    return $view;
</code></pre>

<p>}
&#8220;`</p>

<h2>Routing Groups</h2>

<p>When a routing filter needs to be applied to multiple routes, it is useful to implement this as a route group. When routes are grouped, for an route within the group to be accessed, the filter must be satisfied. This is incredibly useful when creating pages that all require the user to be authenticated. A route group is setup in the following way</p>

<pre><code>Route::group(array('before' =&gt; 'authed'), function()
{
    Route::get('/account/landing', array('as' =&gt; 'myprotech', 'uses' =&gt; 'AccountController@getLanding'));

    Route::get('/account/courses', array('as' =&gt; 'student_courses', 'uses' =&gt; 'AccountController@getStudentCourses'));

    Route::get('/account/student_account', array('as' =&gt; 'student_account', 'uses' =&gt; 'AccountController@getStudentAccount'));
});

Route::filter('authed', function()
{
    if (!Auth::check())
    {
        Session::flash('message', 'You must login to view this page.');
        return Redirect::guest(route('display_login'));
    }
});
</code></pre>

<p>The route group accepts an array with the filter name(s) and a function that contains the routes. Within the routing group, to access any of the three routes, the <em>authed</em> filter must be satisfied, This filter checks to ensure the current user is logged in. If the user is not logged in, a message is flashed for the next session, and they are redirected to the login screen. Here the Redirect::guest function is used to when valid credentials are supplied, the user if logged in and they are redirected to their original destination. This is a very elegant solution to a common control structure, and simplifies site code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel Routing and Controllers]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/27/laravel-routing-and-controllers/"/>
    <updated>2015-02-27T22:33:01-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/27/laravel-routing-and-controllers</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Routing</h2>

<p>Routing in Laravel is the process of taking HTTP requests, like GET and POST, taking the appropiate action. This is frequently routing the request to a controller. Laravel houses route definitions in</p>

<pre><code>app/routes.php
</code></pre>

<p>Routes in this file can respond to one, many, or all HTTP request verbs.</p>

<p>This would respond to POST:</p>

<pre><code>Route::post('/', function()
{
    return 'POST: Hello World';
});
</code></pre>

<p>This route responds to GET and POST:</p>

<pre><code>Route::match(array('GET', 'POST'), '/', function()
{
    return 'GET &amp; POST: Hello World';
});
</code></pre>

<p>These two previous route examples do not register names with the route handlers. This makes it slightly less easy to refer to the routes in view, to create URLs. It is a beneficial practice to always associative a name with a declared route. To declare a named route in Laravel</p>

<pre><code>Route::get('/account/my_account', array('as' =&gt; 'my_account', function()
{
    return 'GET "my_account" route: Hello World';
}));
</code></pre>

<p>This route responds to the GET verb for requests to /account/my_account. The route can be referred to with the following in views to create URLs that would link to the named route</p>

<pre><code>URL::route('my_account');
</code></pre>

<p>Although all these basic routes have their uses, often URL parameters are required for the effective operation of a page. A route with a parameter is declared as</p>

<pre><code>Route::get('/account/my_account/{id}', array('as' =&gt; 'my_account', function()
{
    return 'GET "my_account" route: ' . $id;
}));
</code></pre>

<p>This route requires the request have an id parameter. A parameter is optional if followed by a &lsquo;?&rsquo;. In this case there was no question mark after if, so the parameter is required.</p>

<p>One other useful construct that can be attached to routes is the filter. Filters allow preprocessing of a HTTP request before it gets routed to a particular location, like a controller. This is useful for processes like authentication checks. To declare a filter that would check if the user is authenticated</p>

<pre><code>Route::filter('auth', function()
{
    if (!Auth::user())
    {
        return Redirect::to('sign_in');
    }
});
</code></pre>

<p>This filter can then be applied to a route</p>

<pre><code>Route::get('my_account', array('before' =&gt; 'auth', function()
{
    return 'Account Info';
}));
</code></pre>

<p>When the filter is applied to that route, it will ensure that all users accessing the my_account page are logged in. If the user is not logged in, they are redirected to the sign_in page.</p>

<p>All of the previously detailed routes had string or route returns, it is much more common to have routes that direct to controllers.</p>

<h2>Controllers</h2>

<p>Controllers in Laravel function similarly to controllers in other MVC structures. They get data from the model (the database), process this data, and the pass it to a Laravel view. The controller may also do other preliminary processing like user authentication or key validation. The first step to using a Laravel controller is declaring a route to the controller</p>

<pre><code>Route::get('/', array('as' =&gt; 'home', 'uses' =&gt; 'HomeController@getIndex'));
</code></pre>

<p>This is a basic example that declares a named route &lsquo;home&rsquo; that responds to all GET requests to the index page and routes them to the getIndex method in the HomeController. After declaring this route the HomeController file should be created in the app/controllers directory. An appropiate controller would look something like the following</p>

<pre><code>&lt;?php

class HomeController extends BaseController {

    public function getIndex()
    {

            $view = View::make('home');

            return $view;

    }

}

?&gt;
</code></pre>

<p>This controller contains the needed getIndex method and in this method the &lsquo;home&rsquo; view is created and returned. A more advanced method may include a database call</p>

<pre><code>public function getIndex()
    {

            $view = View::make('home');

            $content = Content::where('display', '=', 1)-&gt;get();
            $view-&gt;with('content', $content);

            return $view;

    }
</code></pre>

<p>The get index method now queries the database for all content that should be displayed. The data is passed to the created view using the &lsquo;with&rsquo; method. The first parameter is the variable name the view will use to refer to the data and the second parameter is the data itself. A more advanced view would include many more methods to handle several associated request. An account controller could have sign in, sign out, get sign in page, and get account methods.</p>

<p>Another useful construct that can be inserted into controller methods in the Redirect. Redirects do just what their name says, redirected. One possible use case is redirection after authentication.</p>

<pre><code>public function postSignIn(){
    $email = Input::get('email');
    $password = Input::get('password');

    if (Auth::attempt(array('email' =&gt; $email, 'password' =&gt; $password)))
    {
        Session::flash('message', 'You have been logged in.');
        return Redirect::intended(route('home'));
    }

    Session::flash('message', 'Your credentials are invalid.');
    return Redirect::to(route('display_login'));
}
</code></pre>

<p>These are the structures that I found most useful for my project. I valued the control found with explicitly defining routes to controllers. Laravel offers many other variation and tools with controller that are detailed <a href="http://laravel.com/docs/4.2/controllers" title="Laravel Controllers">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel and Blade]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/16/laravel-and-blade/"/>
    <updated>2015-02-16T13:38:10-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/16/laravel-and-blade</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>What is Blade?</h2>

<p>Blade is a template engine that comes with the Laravel framework. Blade is incredibly useful because it provides control structures, layout inheritance, and function definitions. The control structures keep to code simple, but retain the power of raw PHP control structures.</p>

<h2>How to use it.</h2>

<p>The simplest Blade structure allow for the echoing of information. In addition to echoing the information, Laravel escapes the content to prevent malicious code execution. With raw PHP, the opening and closing tags would be needed in addition to a function call for output cleaning. The blade syntax is</p>

<p>{% raw %}
<code>
Blade content {{ $content }}
</code>
{% endraw %}</p>

<p>Blade allows for extension of this syntax with existence checking. This becomes very useful when outputting content from a database. If there are nulls or empty strings, the defined string will be output.</p>

<p>{% raw %}
<code>
{{ isset($content) ? $content : 'No Content' }}
</code>
{% endraw %}</p>

<p>Beyond these simple structures, Blade provides support for more advanced control structures like if statements and loops. To construct an if statement (and declare other Blade keywords), the @ symbol us used</p>

<pre><code>@if ($fish == "1")
    One Fish
@elseif ($fish == "2")
    Two Fish
@elseif ($fish == "red")
    Red Fish
@elseif ($fish == "blue")
    Blue Fish
@else
    Not a fish
@endif
</code></pre>

<p>Blade also provide support for for, foreach, forelse, and while loops. The foreach loop is frequently used after fetching information from the database to output it to the user.</p>

<p>{% raw %}
<code>
@foreach ($all_fish as fish)
    &lt;p&gt;{{ $fish-&gt;type }} Fish&lt;/p&gt;
@endforeach
</code>
{% endraw %}</p>

<p>Although no significant additional functionality is provided, the blade structures ensure the code remains clean and readable. This will improve debug time and improvements and maintenance in the future.</p>

<p>Blade is also very powerful because it provides support for inheritance of layouts. For instance, a a base layout could be defined with all the basic information. The HTML tags, head tags, style information needed for all pages, and anything else that can be included for all pages. This base layout can be included in other layouts, moreover content can be injected from the child to the parent layout. A base layout could be defined, another layout for generic content pages and additional layouts for specialized content all injecting content into the base layout and inheriting its structure.</p>

<p>The parent layout
{% raw %}
&#8220;`</p>

<!-- views/layouts/base.blade.php -->


<p><html>
    <head>
        <link rel="stylesheet" type="text/css" href="style_default.css">
        @yield(&lsquo;css&rsquo;)
    </head>
    <body>
        <div class="container">
            @yield(&lsquo;content&rsquo;)
        </div>
    </body>
</html>
&#8220;`
{% endraw %}</p>

<p>A child layout
{% raw %}
&#8220;`
@extends(&lsquo;base.master&rsquo;)</p>

<p>@section(&lsquo;css&rsquo;)
    <link rel="stylesheet" type="text/css" href="special_styles.css">
@stop</p>

<p>@section(&lsquo;content&rsquo;)
    <p>This is my body content.</p>
@stop
&#8220;`
{% endraw %}</p>

<p>Finally, Blade support definition of custom function in the same way a function can be defined in PHP. The defined function is access using the @ sign, like when using other Blade keywords. This is very useful when defined common formatting or output procedures, like formatting a MySQL DATETIME for output to the user. The following piece of code will take a date/time input and convert it to a date formatted as a two digit month, a slash, and then the two digit day.</p>

<p>{% raw %}
&#8220;`
Blade::extend(function($view, $compiler)
{
    $pattern = $compiler->createMatcher(&lsquo;datetime&rsquo;);</p>

<pre><code>return preg_replace($pattern, '$1&lt;?php echo $2-&gt;format(\'m/d\'); ?&gt;', $view);
</code></pre>

<p>});
&#8220;`
{% endraw %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel and the Database]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/10/laravel-and-the-database/"/>
    <updated>2015-02-10T23:13:31-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/10/laravel-and-the-database</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Even before web development, Laravel begins bringing improvements to database operations. To improve development, Laravel provides a query builder, the Eloquent ORM, Migrations and Seeding. Although all these tools may not cater perfectly to every scenario encountered, the benefits tend to outweigh costs encountered.</p>

<h2>The Database Configuration</h2>

<p>Before any specific features are discussed, it is useful to be aware of Laravel&rsquo;s database configuration. The database configuration file is location in app/config/database.php. Here the default database can be selected and other database conncetions can be specified. Laravel supports connection with MySQL, Postgres, SQLite, and SQL Server. This file also set that table where Laravel will store its migrations. All database configuration options should be placed in this file.</p>

<h2>Laravel&rsquo;s Query Builder</h2>

<p>Laravel&rsquo;s query builder tends to be as powerful as raw SQL. It also protects against SQL injection so string cleaning is not necessary. Another benefit of the query builder is the simplicity and cleanliness of the code. A select statement can be done with the following line</p>

<pre><code>```
$users = DB::table('users')-&gt;get();
```
</code></pre>

<p>There is no need to specify a SQL string or have another call to run the query. The total number of characters is also reduced compared to the typical PHP/SQL implementation. All of the attributes are then accessed in the following fashion. This too is as simple as the select statement.</p>

<pre><code>```
foreach ($users as $user)
{
    var_dump($user-&gt;name);
}
```
</code></pre>

<p>A more advanced query may look like the follwing. It retains the simplicity of the former operations as well as the power of raw PHP/SQL.</p>

<pre><code>```
$users = DB::table('users')
                -&gt;orderBy('name', 'desc')
                -&gt;groupBy('count')
                -&gt;having('count', '&gt;', 100)
                -&gt;get();
```
</code></pre>

<p>The query builder also supports all of the other normal SQL functions, but all those will not be described here. One point where the query builder becomes somewhat more cumbersome than SQL is when an advanced where clause is needed. When such a clause is required, a closure must be used. A Laravel closure is an anonymous function used within another construct. The following shows an advanced where with a closure</p>

<pre><code>```
DB::table('users')
        -&gt;where('name', '=', 'John')
        -&gt;orWhere(function($query)
        {
            $query-&gt;where('votes', '&gt;', 100)
                  -&gt;where('title', '&lt;&gt;', 'Admin');
        })
        -&gt;get();
```
</code></pre>

<p>Overall, the query builder is much more organized than using raw PHP/SQL. Since everything is also implemented using OO concepts, mistakes are much less common. Operations will only be supported if they are valid for the current object in use. However, this the most basic way to interact with a database under the Laravel framework. The Eloquent ORM is much more advanced and provide more capabilities.</p>

<h2>Eloquent ORM</h2>

<p>Eloquent ORM is Laravel&rsquo;s implementation of an Active Record system. All tables in the database are tied to Models, so all table can be interacted with as objects. All models should be housed in the app/models directory. A basic sample model would look like the following</p>

<pre><code>```
class Vendor extends Model {

    protected $table = 'Vendor';

    public function product()
    {   
        return $this-&gt;hasMany('Product', 'product_id');
    }

}       
```
</code></pre>

<p>This is a basic model for Vendors and the relationship with Products is implemented with the hasMany function.</p>

<p>Then to interact with the model, this statement could be used</p>

<pre><code>```
$vendors = Vendor::all();
```
</code></pre>

<p>This returns all of the users in the form of objects. The attributes are retrieved in the same was as with the query builder. Although it retains the organization of the query builder, Eloquent ORM does not cater well to complex queries. I found myself frequently using elements of the basic query builder. Eloquent makes up for this with its relationship evaluation. Referencing the previous example, after getting the vendors, the products can be iterated over without any other queries. In Laravel this is called a dynamic property and is a huge advantage of the framework.</p>

<h2>Migrations</h2>

<p>One of the most useful database tools offered by Laravel is the migration. Laravel migration are version control for the database. When a change must be made to the database, a new migration is created. All migration have an up and down method that are run for migrate and rollback respectively. After editing the migration, all migration can be run with</p>

<pre><code>```
php artisan migrate
```
</code></pre>

<p>This is like pushing a series of commits with git.</p>

<p>To roll back run</p>

<pre><code>```
php artisan migrate:rollback
```
</code></pre>

<p>Migrations can be used to create the database and keep track of call changes that occur over the lifetime of a project. If a problem is encountered a roll back can be issued and another can be created to remedy the problem.</p>

<h2>Seeding</h2>

<p>Seeding is another useful feature Laravel provides although not extremely innovative. Seeding can be accomplished with a simple PHP script. Laravel does not provide any truly innovative or extremely capability. It is however useful for organization purposes to have to migrations and seeding script location in one place. it avoids the problem of dispersing scripts and functions across a webserver which happens with many projects. A typical migration consists of the following</p>

<pre><code>```
class UserTableSeeder extends Seeder {

    public function run()
    {
        DB::table('users')-&gt;delete();

        User::create(array('email' =&gt; 'foo@bar.com'));
    }

}
```
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up the Development Environment]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/10/setting-up-the-development-environment/"/>
    <updated>2015-02-10T20:21:10-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/10/setting-up-the-development-environment</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>What is the Homestead and Vagrant?</h2>

<p>Homestead and Vagrant are two separate products the aid the development of Laravel applications. Before Homestead is discussed in detail, it is useful to have an understanding of Vagrant.</p>

<p>Vagrant is used to automate and simplify the construction of development environments that are portable, lightweight and easy to duplicate. Normally the process of setting up a development environment consists of creating a virtual disk, mounting an ISO, going through an OS installation and installing all required packages (This process frequently needs to be done more than once given how unstable certain development environment are). Vagrant&rsquo;s pre-built environment are known as <em>boxes</em>. After a box is added to the local vagrant installation and started it supports operations including SSH, folder syncing, and web host setup. With vagrant, boxes are downloaded with all the setup done in advance. The box is added to vagrant via command line and the <em>up</em> command is called. The process is much shorter and many degrees simpler then the normal process without vagrant. Since boxes are downloaded already set up, this also creates identical environments if multiple developers are involved on a project. Developing a project in identical environments create code that is much more stable and likely to run in a production environment (If the development environment is similar to that of production). Now that a basic understanding of Vagrant has been established, the Homestead can be discussed.</p>

<p>The Homestead is a Vagrant box produced by Taylor Otwell, the creator of Laravel. Since the Homestead was created by the &ldquo;creator,&rdquo; it is much more stable and well suited to Laravel development than a ordinary setup. Less configuration is all required since much of that has been done already. The Homestead includes Ubuntu 14.04, PHP, Nginx web server, and MySQL, configured and ready for development from startup (There are other included software packages but these are the most notable for my project).</p>

<h2>Installing the Homestead</h2>

<ol>
<li><p>To use the Homestead, <a href="https://www.virtualbox.org/wiki/Downloads" title="Install VirtualBox">VirtualBox</a> and <a href="http://www.vagrantup.com/downloads.html" title="Install Vagrant">Vagrant</a> must be installed.</p></li>
<li><p>Next, the Laravel Homestead box must be added to the local vagrant installation. This is done with the following command</p></li>
</ol>


<pre><code>vagrant box add laravel/homestead
</code></pre>

<ol>
<li>Following the download of the Homestead box, the Homestead CLI to start, stop, and modify the Homestead box must be installed. This can be done with composer and PHP or by cloning the git repo. I do not like to have a PHP installation running on my local machine, so I insatlled it via the git repo. To clone the repo use the following command (Be sure to clone the repo to a central location where most laraval applications can be found)</li>
</ol>


<pre><code>git clone https://github.com/laravel/homestead.git Homestead
</code></pre>

<p>To create the Homestead configuration file, run (The file Homestead.yaml will be created in ~/.homestead)</p>

<pre><code>bash init.sh
</code></pre>

<p>Next the SSH key must be set up using the ssh-keygen command. I selected the default file name and path so the Homestead.yaml file would not need to be edited.</p>

<pre><code>ssh-keygen -t rsa -C "gmcdaid@homestead"
</code></pre>

<p>After configuring the SSH Key, shared folders need to be set up. Shared folder are shared between the OS and Vagrant Box. A change made on the local file system will be instantly reflected in that of the Vagrant Box. This is a very useful feature included in the Vagrant work flow. To configure folder sharing, edit the Homestead.yaml file to reflect something like the following (The mapping is from the local machine to the vagrant box)</p>

<pre><code>folders:
    - map: C:\\laravel\\code
      to: /home/vagrant/Code/
</code></pre>

<p>Now, sites for the Homestead need to be configured. Sites operate much like Virtual Hosts with Apache. Specified URLs get mapped to a particular directory on the filsystem. When a request is made to a URL the web server on the Homestead box will server pages in the specified directory. Mapping for sites is similar to mapping for folders</p>

<pre><code>sites:
    - map: homestead.app
      to: /home/vagrant/Code/laravel/public
</code></pre>

<p>Both sites and folders can have multiple entries. And something found in folders does not need to be in sites. If PHP scripts need to be run but not in a web browser, a folder mapping can be created without a site map.</p>

<p>The only software package not included in the Homstead which is necessary to my personal work flow is phpMyAdmin. Luckily, it was not hard to install. (The install process assumes Laravel projects are in /home/vagrant/Code)</p>

<p>First run</p>

<pre><code>sudo apt-get install phpmyadmin (Do not select apache or lighttpd, just continue)
</code></pre>

<p>Then</p>

<pre><code>cd ~/Code &amp;&amp; serve phpmyadmin.app /usr/share/phpmyadmin/
</code></pre>

<p>Finally, the following should be added to the hosts file on the main machine</p>

<pre><code>127.0.0.1 phpmyadmin.app
</code></pre>

<p>Start the Homestead box with</p>

<pre><code>vagrant up
</code></pre>

<p>The phpMyAdmin interface should now be available at <a href="http://phpmyadmin.app:8000/" title="phpMyAdmin">http://phpmyadmin.app:8000/</a>. The default username/password is homestead/secret.</p>

<p>Laravel&rsquo;s homestead environment is now fully configured and ready for development.</p>
]]></content>
  </entry>
  
</feed>
