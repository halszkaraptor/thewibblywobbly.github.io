<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Is 2015 | To Boldly Code...]]></title>
  <link href="http://boldlycoding.com/blog/categories/is-2015/atom.xml" rel="self"/>
  <link href="http://boldlycoding.com/"/>
  <updated>2015-04-08T02:58:05-04:00</updated>
  <id>http://boldlycoding.com/</id>
  <author>
    <name><![CDATA[George McDaid]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laravel and Forms]]></title>
    <link href="http://boldlycoding.com/blog/2015/03/29/laravel-and-forms/"/>
    <updated>2015-03-29T00:20:38-04:00</updated>
    <id>http://boldlycoding.com/blog/2015/03/29/laravel-and-forms</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Laravel supports many HTML form functions and adds a great deal of functionality that makes code more concise and reusable.</p>

<h2>Creating Forms</h2>

<p>The most basic of the form functions is that which creates and closes the form. The URL parameter specifies where the submission should be directed to. By default, forms use the POST HTTP verb. This can be changed to GET or any other valid HTTP verb.</p>

<pre><code>Form::open(array('url' =&gt; route('form')))
    //
Form::close() 
</code></pre>

<p>Also by default Laravel embeds a CSRF (Cross Site Request Forgery) token in all forms. This token ensures all form submissions are genuine and from the application. The token can be seen with the following command.</p>

<pre><code>echo Form::token();
</code></pre>

<p>Some of the basic control function that Laravel supports are</p>

<pre><code>Form::radio('answer_1_radio', '5', false, array('class' =&gt; 'fancy-radio'))
Form::hidden('date_id', $date)
Form::label('email', 'E-Mail Address')
Form::text('username')
Form::checkbox('name', 'value');
</code></pre>

<p>All of these basic functions have a very similar signature. The radio button specifies a value on selection and also adds a CSS class. Class classes can be added to any of the other fields in the same way. The arry can also contain other HTML values to add like id.</p>

<p>The select function has a signature that is a bit longer than the other functions</p>

<pre><code>
Form::select('answer_16_selection', 
                array(
                    '0' =&gt; 'Please select an option',
                    '1' =&gt; 'Web Site',
                    '2' =&gt; 'Manager',
                    '3' =&gt; 'Mail',
                    '4' =&gt; 'Call',
                    '5' =&gt; 'E-Mail',
                    '6' =&gt; 'web Search',
                    '7' =&gt; 'Co-worker',
                    '8' =&gt; 'Another Course',
                    '9' =&gt; 'Other'
                ),
                0

            ) 
}}
</code></pre>

<h2>Form Validation</h2>

<p>Form validation is much more interesting and extensive than form construction. Normally, form validation is placed in the controller associated with a form. The specifics of where to place the validation code and how to route to a form will be discussed in the next section.</p>

<p>For validation begins with definition of the validation rules. Rules are provided to Laravel using an array</p>

<pre><code>$rules = array(
                'answer_1_text'        =&gt; 'required',
                'answer_2_selection'   =&gt; 'required',
                'password'             =&gt; 'required',
                'password_confirm'     =&gt; 'required|same:password' 
                'answer_3_text'        =&gt; 'required|integer|min:5|max:20',
            );
</code></pre>

<p>Laravel will attempt to generate error messages when validation failes based on the field type and validation requirements. Although these may be sufficient, often more descriptive error messages are desired.</p>

<pre><code>$messages = array(
                'answer_1_text.required'        =&gt; 'Enter your first name.', 
                'answer_2_selection.required'   =&gt; 'Please select your title',
                'password.required'             =&gt; 'Enter a password',
                'password_confirm.required'     =&gt; 'Please confirm your password'
                'password_confirm.same'         =&gt; 'The passwords must match',
                'answer_3_text.min'             =&gt; 'The number must be at least 5',
                'answer_3_text.max'             =&gt; 'The number must be no more than 20'
            );
</code></pre>

<p>To pass the rules with the corresponding error messages, the following command is issued</p>

<pre><code>$validator = Validator::make(Input::all(), $rules, $messages);
</code></pre>

<p>To test the validator for failure an if-statement is used</p>

<pre><code>if ($validator-&gt;fails()) {
    $messages = $validator-&gt;messages();
    return Redirect::to(route('form'))-&gt;withErrors($validator)-&gt;withInput(Input::all());
}else{

    //Necessary processing of valid inputs

    Session::flash('success', 'Your input has been submitted.');
    return Redirect::to(route('home')); 

}
</code></pre>

<p>If there are errors, in this case, the messages are fetched from the validator and the user is redirected to the form with the messages passed to the view. If there is not failure, necessary processing is done and the user is redirected to an appropriate destination.</p>

<p>It is also useful to note that more advanced validation can be applied to filed. One useful construct is conditional validation. Conditional is useful when a field, or set of fields, must be validated when another is present or has a particular value. One relevant use case is shipping and billing information. If the user has billing information that is the same as shipping information typically a box is checked and then there is no need to validate the billing information input fields. However, if the check box is not checked, the fields should be validated. This can be accomplished with code similar to the following. This code would be placed directly after the Validator::make call.</p>

<pre><code>$validator-&gt;sometimes(['answer_13_text', 'answer_15_text', 'answer_16_selection', 'answer_17_text'], 'required', function($input)
    {
        return empty($input-&gt;sameas);
    });
</code></pre>

<p>This code will validate fields 13, 15, 16, and 17 only if the sameas input field value (a check box) is not present. The validation rules and messages should be passed into the appropriate array regardless of the result of this function.</p>

<h2>Handling Form Requests</h2>

<p>To begin handling form requests, appropriate routes must be declared. Note that the route where submissions are received uses the POST HTTP verb.</p>

<pre><code>Route::get('/2015_survey', array('as' =&gt; 'survey', 'uses' =&gt; 'ContentController@getSurvey'));

Route::post('/2015_survey', array('as' =&gt; 'submitSurvey', 'uses' =&gt; 'ContentController@postSurvey'));
</code></pre>

<p>Next controller actions must be declared. The code within the post handler should be similar to what was discussed in the previous section.</p>

<pre><code>public function getSurvey(){
    $view = View::make("2015_survey");
    return $view;
}

public function postSurvey(){

    //Rules
    //Messages
    //Make the validator
    //Any conditional validation
    //Check validator for failure

}
</code></pre>

<p>Finally the view must be declared the view should use the form construction functions discussed in the first section. There are a few more Laravel function that should be noted at this point. In the code from the previous section, when error occur, they are passed to the view to use the errors the following should be done where the errors need to be displayed</p>

<pre><code>@if ($errors-&gt;has('answer_6_radio')) &lt;span class="red" style="margin-left: 5px;"&gt;$errors-&gt;first('answer_6_radio')&lt;/span&gt; @endif
</code></pre>

<p>The previous input values are also passed to the view using the code from the previous section to insert these values back into the view</p>

<pre><code>&lt;textarea name="answer_13_textarea" class="input-off"&gt;Input::old('answer_13_textarea')&lt;/textarea&gt;
</code></pre>

<p>The same construct can be used to pass the value to the value field, this would be passed to a Laravel form component function in the value field.</p>

<p>Overall, these features streamline form creation and processing code. Code with an abundance of if statements is eliminated. The Laravel code is also much more reusable. The built in security features also ease the processing of dealing with HTML forms.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel and Advanced Routing to Controllers]]></title>
    <link href="http://boldlycoding.com/blog/2015/03/13/laravel-and-advanced-routing-to-controllers/"/>
    <updated>2015-03-13T03:08:01-04:00</updated>
    <id>http://boldlycoding.com/blog/2015/03/13/laravel-and-advanced-routing-to-controllers</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Following the previous discussion of routes and controllers, there are other constructs within the Laravel framework that are also worth noting.</p>

<h2>Parameter Constraints</h2>

<p>Laravel allows for constraints to be placed on route parameters, which were discussed in the previous post. Parameter constraints are more basic to type than route filters, but just as powerful. Route parameter constraints are implemented using regular expressions listed with an accompanying parameter name. Before a request is passed to the controller within a route function, the parameter must satisfy the regular expression.</p>

<p>The first route must only be alphabetical, while the second must be numerical. Laravel will only dispatch a request to these routes if the parameter meets the regular expression.
&#8220;`
Route::get(&lsquo;user/{name}&rsquo;, function($name)
{
    //
})
->where(&lsquo;name&rsquo;, &lsquo;[A-Za-z]+&rsquo;);</p>

<p>Route::get(&lsquo;user/{id}&rsquo;, function($id)
{
    //
})
->where(&lsquo;id&rsquo;, &lsquo;[0-9]+&rsquo;);
&#8220;`</p>

<p>The routes can also be combined and pass an array of constraints
<code>
Route::get('user/{id}/{name}', function($id, $name)
{
    //
})
-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+'])
</code></p>

<p>Although not this it is not found within the routing file, it is useful to note the <em>firstOrFail</em> and <em>findOrFail</em> functions here. These functions are used to find data within a table using an identifier, when the record is not found, an exception is thrown. This failure can then propagate up to a 404 error page, and no routing or redirection is needed within the controller. <em>findOrFail($id)</em> is used when the identifier being used is the primary key, <em>firstOrFail()</em> is used when the identifier is not the primary key.</p>

<p>This function will fail if the content identifier does not exist. The error can be caught in the app&rsquo;s config file and a 404 view can be presented.
&#8220;`
public function getContent($content = null){
    $view = View::make(&lsquo;content&rsquo;);</p>

<pre><code>$content = Content::findOrFail($id);

$view-&gt;with('content', $content);

return $view;
</code></pre>

<p>}
&#8220;`</p>

<p>Another variation with the <em>firstOrFail</em> function, here the primary key is not used. The content URL is compared to other URLs in the database.
&#8220;`
public function getContent($url = null)
{</p>

<pre><code>    $view = View::make('content');

    $content = Content::where('url', '=', $url)-&gt;firstOrFail();

    $view-&gt;with('content', $content);

    return $view;
</code></pre>

<p>}
&#8220;`</p>

<h2>Routing Groups</h2>

<p>When a routing filter needs to be applied to multiple routes, it is useful to implement this as a route group. When routes are grouped, for an route within the group to be accessed, the filter must be satisfied. This is incredibly useful when creating pages that all require the user to be authenticated. A route group is setup in the following way</p>

<pre><code>Route::group(array('before' =&gt; 'authed'), function()
{
    Route::get('/account/landing', array('as' =&gt; 'myprotech', 'uses' =&gt; 'AccountController@getLanding'));

    Route::get('/account/courses', array('as' =&gt; 'student_courses', 'uses' =&gt; 'AccountController@getStudentCourses'));

    Route::get('/account/student_account', array('as' =&gt; 'student_account', 'uses' =&gt; 'AccountController@getStudentAccount'));
});

Route::filter('authed', function()
{
    if (!Auth::check())
    {
        Session::flash('message', 'You must login to view this page.');
        return Redirect::guest(route('display_login'));
    }
});
</code></pre>

<p>The route group accepts an array with the filter name(s) and a function that contains the routes. Within the routing group, to access any of the three routes, the <em>authed</em> filter must be satisfied, This filter checks to ensure the current user is logged in. If the user is not logged in, a message is flashed for the next session, and they are redirected to the login screen. Here the Redirect::guest function is used to when valid credentials are supplied, the user if logged in and they are redirected to their original destination. This is a very elegant solution to a common control structure, and simplifies site code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel Routing and Controllers]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/27/laravel-routing-and-controllers/"/>
    <updated>2015-02-27T22:33:01-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/27/laravel-routing-and-controllers</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Routing</h2>

<p>Routing in Laravel is the process of taking HTTP requests, like GET and POST, taking the appropiate action. This is frequently routing the request to a controller. Laravel houses route definitions in</p>

<pre><code>app/routes.php
</code></pre>

<p>Routes in this file can respond to one, many, or all HTTP request verbs.</p>

<p>This would respond to POST:</p>

<pre><code>Route::post('/', function()
{
    return 'POST: Hello World';
});
</code></pre>

<p>This route responds to GET and POST:</p>

<pre><code>Route::match(array('GET', 'POST'), '/', function()
{
    return 'GET &amp; POST: Hello World';
});
</code></pre>

<p>These two previous route examples do not register names with the route handlers. This makes it slightly less easy to refer to the routes in view, to create URLs. It is a beneficial practice to always associative a name with a declared route. To declare a named route in Laravel</p>

<pre><code>Route::get('/account/my_account', array('as' =&gt; 'my_account', function()
{
    return 'GET "my_account" route: Hello World';
}));
</code></pre>

<p>This route responds to the GET verb for requests to /account/my_account. The route can be referred to with the following in views to create URLs that would link to the named route</p>

<pre><code>URL::route('my_account');
</code></pre>

<p>Although all these basic routes have their uses, often URL parameters are required for the effective operation of a page. A route with a parameter is declared as</p>

<pre><code>Route::get('/account/my_account/{id}', array('as' =&gt; 'my_account', function()
{
    return 'GET "my_account" route: ' . $id;
}));
</code></pre>

<p>This route requires the request have an id parameter. A parameter is optional if followed by a &lsquo;?&rsquo;. In this case there was no question mark after if, so the parameter is required.</p>

<p>One other useful construct that can be attached to routes is the filter. Filters allow preprocessing of a HTTP request before it gets routed to a particular location, like a controller. This is useful for processes like authentication checks. To declare a filter that would check if the user is authenticated</p>

<pre><code>Route::filter('auth', function()
{
    if (!Auth::user())
    {
        return Redirect::to('sign_in');
    }
});
</code></pre>

<p>This filter can then be applied to a route</p>

<pre><code>Route::get('my_account', array('before' =&gt; 'auth', function()
{
    return 'Account Info';
}));
</code></pre>

<p>When the filter is applied to that route, it will ensure that all users accessing the my_account page are logged in. If the user is not logged in, they are redirected to the sign_in page.</p>

<p>All of the previously detailed routes had string or route returns, it is much more common to have routes that direct to controllers.</p>

<h2>Controllers</h2>

<p>Controllers in Laravel function similarly to controllers in other MVC structures. They get data from the model (the database), process this data, and the pass it to a Laravel view. The controller may also do other preliminary processing like user authentication or key validation. The first step to using a Laravel controller is declaring a route to the controller</p>

<pre><code>Route::get('/', array('as' =&gt; 'home', 'uses' =&gt; 'HomeController@getIndex'));
</code></pre>

<p>This is a basic example that declares a named route &lsquo;home&rsquo; that responds to all GET requests to the index page and routes them to the getIndex method in the HomeController. After declaring this route the HomeController file should be created in the app/controllers directory. An appropiate controller would look something like the following</p>

<pre><code>&lt;?php

class HomeController extends BaseController {

    public function getIndex()
    {

            $view = View::make('home');

            return $view;

    }

}

?&gt;
</code></pre>

<p>This controller contains the needed getIndex method and in this method the &lsquo;home&rsquo; view is created and returned. A more advanced method may include a database call</p>

<pre><code>public function getIndex()
    {

            $view = View::make('home');

            $content = Content::where('display', '=', 1)-&gt;get();
            $view-&gt;with('content', $content);

            return $view;

    }
</code></pre>

<p>The get index method now queries the database for all content that should be displayed. The data is passed to the created view using the &lsquo;with&rsquo; method. The first parameter is the variable name the view will use to refer to the data and the second parameter is the data itself. A more advanced view would include many more methods to handle several associated request. An account controller could have sign in, sign out, get sign in page, and get account methods.</p>

<p>Another useful construct that can be inserted into controller methods in the Redirect. Redirects do just what their name says, redirected. One possible use case is redirection after authentication.</p>

<pre><code>public function postSignIn(){
    $email = Input::get('email');
    $password = Input::get('password');

    if (Auth::attempt(array('email' =&gt; $email, 'password' =&gt; $password)))
    {
        Session::flash('message', 'You have been logged in.');
        return Redirect::intended(route('home'));
    }

    Session::flash('message', 'Your credentials are invalid.');
    return Redirect::to(route('display_login'));
}
</code></pre>

<p>These are the structures that I found most useful for my project. I valued the control found with explicitly defining routes to controllers. Laravel offers many other variation and tools with controller that are detailed <a href="http://laravel.com/docs/4.2/controllers" title="Laravel Controllers">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel and Blade]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/16/laravel-and-blade/"/>
    <updated>2015-02-16T13:38:10-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/16/laravel-and-blade</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>What is Blade?</h2>

<p>Blade is a template engine that comes with the Laravel framework. Blade is incredibly useful because it provides control structures, layout inheritance, and function definitions. The control structures keep to code simple, but retain the power of raw PHP control structures.</p>

<h2>How to use it.</h2>

<p>The simplest Blade structure allow for the echoing of information. In addition to echoing the information, Laravel escapes the content to prevent malicious code execution. With raw PHP, the opening and closing tags would be needed in addition to a function call for output cleaning. The blade syntax is</p>

<p>{% raw %}
<code>
Blade content {{ $content }}
</code>
{% endraw %}</p>

<p>Blade allows for extension of this syntax with existence checking. This becomes very useful when outputting content from a database. If there are nulls or empty strings, the defined string will be output.</p>

<p>{% raw %}
<code>
{{ isset($content) ? $content : 'No Content' }}
</code>
{% endraw %}</p>

<p>Beyond these simple structures, Blade provides support for more advanced control structures like if statements and loops. To construct an if statement (and declare other Blade keywords), the @ symbol us used</p>

<pre><code>@if ($fish == "1")
    One Fish
@elseif ($fish == "2")
    Two Fish
@elseif ($fish == "red")
    Red Fish
@elseif ($fish == "blue")
    Blue Fish
@else
    Not a fish
@endif
</code></pre>

<p>Blade also provide support for for, foreach, forelse, and while loops. The foreach loop is frequently used after fetching information from the database to output it to the user.</p>

<p>{% raw %}
<code>
@foreach ($all_fish as fish)
    &lt;p&gt;{{ $fish-&gt;type }} Fish&lt;/p&gt;
@endforeach
</code>
{% endraw %}</p>

<p>Although no significant additional functionality is provided, the blade structures ensure the code remains clean and readable. This will improve debug time and improvements and maintenance in the future.</p>

<p>Blade is also very powerful because it provides support for inheritance of layouts. For instance, a a base layout could be defined with all the basic information. The HTML tags, head tags, style information needed for all pages, and anything else that can be included for all pages. This base layout can be included in other layouts, moreover content can be injected from the child to the parent layout. A base layout could be defined, another layout for generic content pages and additional layouts for specialized content all injecting content into the base layout and inheriting its structure.</p>

<p>The parent layout
{% raw %}
&#8220;`</p>

<!-- views/layouts/base.blade.php -->


<p><html>
    <head>
        <link rel="stylesheet" type="text/css" href="style_default.css">
        @yield(&lsquo;css&rsquo;)
    </head>
    <body>
        <div class="container">
            @yield(&lsquo;content&rsquo;)
        </div>
    </body>
</html>
&#8220;`
{% endraw %}</p>

<p>A child layout
{% raw %}
&#8220;`
@extends(&lsquo;base.master&rsquo;)</p>

<p>@section(&lsquo;css&rsquo;)
    <link rel="stylesheet" type="text/css" href="special_styles.css">
@stop</p>

<p>@section(&lsquo;content&rsquo;)
    <p>This is my body content.</p>
@stop
&#8220;`
{% endraw %}</p>

<p>Finally, Blade support definition of custom function in the same way a function can be defined in PHP. The defined function is access using the @ sign, like when using other Blade keywords. This is very useful when defined common formatting or output procedures, like formatting a MySQL DATETIME for output to the user. The following piece of code will take a date/time input and convert it to a date formatted as a two digit month, a slash, and then the two digit day.</p>

<p>{% raw %}
&#8220;`
Blade::extend(function($view, $compiler)
{
    $pattern = $compiler->createMatcher(&lsquo;datetime&rsquo;);</p>

<pre><code>return preg_replace($pattern, '$1&lt;?php echo $2-&gt;format(\'m/d\'); ?&gt;', $view);
</code></pre>

<p>});
&#8220;`
{% endraw %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel and the Database]]></title>
    <link href="http://boldlycoding.com/blog/2015/02/10/laravel-and-the-database/"/>
    <updated>2015-02-10T23:13:31-05:00</updated>
    <id>http://boldlycoding.com/blog/2015/02/10/laravel-and-the-database</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Even before web development, Laravel begins bringing improvements to database operations. To improve development, Laravel provides a query builder, the Eloquent ORM, Migrations and Seeding. Although all these tools may not cater perfectly to every scenario encountered, the benefits tend to outweigh costs encountered.</p>

<h2>The Database Configuration</h2>

<p>Before any specific features are discussed, it is useful to be aware of Laravel&rsquo;s database configuration. The database configuration file is location in app/config/database.php. Here the default database can be selected and other database conncetions can be specified. Laravel supports connection with MySQL, Postgres, SQLite, and SQL Server. This file also set that table where Laravel will store its migrations. All database configuration options should be placed in this file.</p>

<h2>Laravel&rsquo;s Query Builder</h2>

<p>Laravel&rsquo;s query builder tends to be as powerful as raw SQL. It also protects against SQL injection so string cleaning is not necessary. Another benefit of the query builder is the simplicity and cleanliness of the code. A select statement can be done with the following line</p>

<pre><code>```
$users = DB::table('users')-&gt;get();
```
</code></pre>

<p>There is no need to specify a SQL string or have another call to run the query. The total number of characters is also reduced compared to the typical PHP/SQL implementation. All of the attributes are then accessed in the following fashion. This too is as simple as the select statement.</p>

<pre><code>```
foreach ($users as $user)
{
    var_dump($user-&gt;name);
}
```
</code></pre>

<p>A more advanced query may look like the follwing. It retains the simplicity of the former operations as well as the power of raw PHP/SQL.</p>

<pre><code>```
$users = DB::table('users')
                -&gt;orderBy('name', 'desc')
                -&gt;groupBy('count')
                -&gt;having('count', '&gt;', 100)
                -&gt;get();
```
</code></pre>

<p>The query builder also supports all of the other normal SQL functions, but all those will not be described here. One point where the query builder becomes somewhat more cumbersome than SQL is when an advanced where clause is needed. When such a clause is required, a closure must be used. A Laravel closure is an anonymous function used within another construct. The following shows an advanced where with a closure</p>

<pre><code>```
DB::table('users')
        -&gt;where('name', '=', 'John')
        -&gt;orWhere(function($query)
        {
            $query-&gt;where('votes', '&gt;', 100)
                  -&gt;where('title', '&lt;&gt;', 'Admin');
        })
        -&gt;get();
```
</code></pre>

<p>Overall, the query builder is much more organized than using raw PHP/SQL. Since everything is also implemented using OO concepts, mistakes are much less common. Operations will only be supported if they are valid for the current object in use. However, this the most basic way to interact with a database under the Laravel framework. The Eloquent ORM is much more advanced and provide more capabilities.</p>

<h2>Eloquent ORM</h2>

<p>Eloquent ORM is Laravel&rsquo;s implementation of an Active Record system. All tables in the database are tied to Models, so all table can be interacted with as objects. All models should be housed in the app/models directory. A basic sample model would look like the following</p>

<pre><code>```
class Vendor extends Model {

    protected $table = 'Vendor';

    public function product()
    {   
        return $this-&gt;hasMany('Product', 'product_id');
    }

}       
```
</code></pre>

<p>This is a basic model for Vendors and the relationship with Products is implemented with the hasMany function.</p>

<p>Then to interact with the model, this statement could be used</p>

<pre><code>```
$vendors = Vendor::all();
```
</code></pre>

<p>This returns all of the users in the form of objects. The attributes are retrieved in the same was as with the query builder. Although it retains the organization of the query builder, Eloquent ORM does not cater well to complex queries. I found myself frequently using elements of the basic query builder. Eloquent makes up for this with its relationship evaluation. Referencing the previous example, after getting the vendors, the products can be iterated over without any other queries. In Laravel this is called a dynamic property and is a huge advantage of the framework.</p>

<h2>Migrations</h2>

<p>One of the most useful database tools offered by Laravel is the migration. Laravel migration are version control for the database. When a change must be made to the database, a new migration is created. All migration have an up and down method that are run for migrate and rollback respectively. After editing the migration, all migration can be run with</p>

<pre><code>```
php artisan migrate
```
</code></pre>

<p>This is like pushing a series of commits with git.</p>

<p>To roll back run</p>

<pre><code>```
php artisan migrate:rollback
```
</code></pre>

<p>Migrations can be used to create the database and keep track of call changes that occur over the lifetime of a project. If a problem is encountered a roll back can be issued and another can be created to remedy the problem.</p>

<h2>Seeding</h2>

<p>Seeding is another useful feature Laravel provides although not extremely innovative. Seeding can be accomplished with a simple PHP script. Laravel does not provide any truly innovative or extremely capability. It is however useful for organization purposes to have to migrations and seeding script location in one place. it avoids the problem of dispersing scripts and functions across a webserver which happens with many projects. A typical migration consists of the following</p>

<pre><code>```
class UserTableSeeder extends Seeder {

    public function run()
    {
        DB::table('users')-&gt;delete();

        User::create(array('email' =&gt; 'foo@bar.com'));
    }

}
```
</code></pre>
]]></content>
  </entry>
  
</feed>
